package gocode

import (
	"bytes"
	"fmt"
	"go/token"
	"log"
	"net"
	"net/rpc"
	"runtime"
	"time"

	"golang.org/x/tools/go/packages"
)

//-------------------------------------------------------------------------
// daemon
//-------------------------------------------------------------------------

type daemon struct {
	listener     net.Listener
	cmd_in       chan int
	autocomplete *autoCompleteContext
	pkgcache     package_cache
	declcache    *decl_cache
	context      package_lookup_context
}

func (this *daemon) resetCache(pkg *packages.Package, start token.Pos) {
	this.pkgcache = new_package_cache()
	this.declcache = new_decl_cache(&this.context)
	this.autocomplete = newAutoCompleteContext(pkg, start, this.pkgcache, this.declcache)
}

const (
	daemon_close = iota
)

func (this *daemon) loop() {
	conn_in := make(chan net.Conn)
	go func() {
		for {
			c, err := this.listener.Accept()
			if err != nil {
				panic(err)
			}
			conn_in <- c
		}
	}()

	timeout := time.Duration(g_config.CloseTimeout) * time.Second
	countdown := time.NewTimer(timeout)

	for {
		// handle connections or server CMDs (currently one CMD)
		select {
		case c := <-conn_in:
			rpc.ServeConn(c)
			countdown.Reset(timeout)
			runtime.GC()
		case cmd := <-this.cmd_in:
			switch cmd {
			case daemon_close:
				return
			}
		case <-countdown.C:
			return
		}
	}
}

func (this *daemon) close() {
	this.cmd_in <- daemon_close
}

var g_daemon *daemon

//-------------------------------------------------------------------------
// server_* functions
//
// Corresponding client_* functions are autogenerated by goremote.
//-------------------------------------------------------------------------

func serverAutoComplete(pkg *packages.Package, start token.Pos, file []byte, filename string, cursor int, context_packed go_build_context) (c []candidate, d int) {
	context := unpack_build_context(&context_packed)
	defer func() {
		if err := recover(); err != nil {
			print_backtrace(err)
			c = []candidate{
				{"PANIC", "PANIC", decl_invalid, "panic"},
			}

			// drop cache
			g_daemon.resetCache(nil, 0)
		}
	}()

	g_daemon.context = context
	g_daemon.resetCache(pkg, start)

	if *g_debug {
		log.Printf("Go project path: %s", pkg.PkgPath)
	}
	g_daemon.autocomplete.p = pkg
	g_daemon.context.CurrentPackagePath = pkg.PkgPath

	if *g_debug {
		var buf bytes.Buffer
		log.Printf("Got autocompletion request for '%s'\n", filename)
		log.Printf("Cursor at: %d\n", cursor)
		if cursor > len(file) || cursor < 0 {
			log.Println("ERROR! Cursor is outside of the boundaries of the buffer, " +
				"this is most likely a text editor plugin bug. Text editor is responsible " +
				"for passing the correct cursor position to gocode.")
		} else {
			buf.WriteString("-------------------------------------------------------\n")
			buf.Write(file[:cursor])
			buf.WriteString("#")
			buf.Write(file[cursor:])
			log.Print(buf.String())
			log.Println("-------------------------------------------------------")
		}
	}
	candidates, d := g_daemon.autocomplete.apropos(file, filename, cursor)
	if *g_debug {
		log.Printf("Offset: %d\n", d)
		log.Printf("Number of candidates found: %d\n", len(candidates))
		log.Printf("Candidates are:\n")
		for _, c := range candidates {
			abbr := fmt.Sprintf("%s %s %s", c.Class, c.Name, c.Type)
			if c.Class == decl_func {
				abbr = fmt.Sprintf("%s %s%s", c.Class, c.Name, c.Type[len("func"):])
			}
			log.Printf("  %s\n", abbr)
		}
		log.Println("=======================================================")
	}
	return candidates, d
}


